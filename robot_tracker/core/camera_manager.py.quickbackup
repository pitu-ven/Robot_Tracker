# core/camera_manager.py
# Version 4.2 - Correction import circulaire et MeasuresTab manquant
# Modification: Suppression import circulaire ligne 17 et ajout import MeasuresTab

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import logging
import threading
from typing import Dict, List, Optional, Any, Union
import time
import numpy as np

try:
    import pyrealsense2 as rs
except ImportError:
    rs = None
    logging.warning("‚ö†Ô∏è pyrealsense2 non disponible - Mode simulation")

# CORRECTION: Suppression de l'import circulaire √† la ligne 17
# from core.camera_manager import CameraManager  # ‚ùå SUPPRIM√â

from hardware.realsense_driver import RealSenseCamera
from hardware.usb3_camera_driver import USB3CameraDriver

logger = logging.getLogger(__name__)

class CameraManager:
    """Gestionnaire centralis√© des cam√©ras avec support multi-types"""
    
    def __init__(self, config):
        self.config = config
        self.cameras = {}
        self.camera_instances = {}
        self.camera_threads = {}
        self.lock = threading.RLock()
        
        # Configuration
        self.target_fps = self.config.get('camera', 'manager.target_fps', 30)
        self.detection_timeout = self.config.get('camera', 'manager.detection_timeout_ms', 3000) / 1000
        self.frame_buffer_size = self.config.get('camera', 'manager.frame_buffer_size', 10)
        
        logger.info("üé• CameraManager initialis√©")
    
    def detect_cameras(self):
        """D√©tecte toutes les cam√©ras disponibles"""
        detected = {}
        
        # D√©tection RealSense
        if rs:
            try:
                ctx = rs.context()
                devices = ctx.query_devices()
                
                for i, device in enumerate(devices):
                    serial = device.get_info(rs.camera_info.serial_number)
                    name = device.get_info(rs.camera_info.name)
                    
                    camera_info = {
                        'type': 'realsense',
                        'serial': serial,
                        'name': name,
                        'alias': f"realsense_{i}",
                        'device_index': i,
                        'capabilities': {
                            'color': True,
                            'depth': True,
                            'infrared': True
                        }
                    }
                    detected[serial] = camera_info
                    
                logger.info(f"‚úÖ {len(detected)} cam√©ra(s) RealSense d√©tect√©e(s)")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erreur d√©tection RealSense: {e}")
        
        # D√©tection USB3 standard
        try:
            usb3_cameras = USB3CameraDriver.detect_cameras()
            for camera_info in usb3_cameras:
                detected[camera_info['serial']] = camera_info
                
            logger.info(f"‚úÖ {len(usb3_cameras)} cam√©ra(s) USB3 d√©tect√©e(s)")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Erreur d√©tection USB3: {e}")
        
        self.cameras = detected
        return detected
    
    def open_camera(self, camera_id: str, alias: Optional[str] = None):
        """Ouvre une cam√©ra par ID ou alias"""
        with self.lock:
            if alias and self.is_camera_open(alias):
                warning_msg = self.config.get('core', 'camera_manager.messages.already_open', 
                                           'Camera already open: {alias}')
                logger.warning(warning_msg.format(alias=alias))
                return True
            
            camera_info = self._get_camera_info(camera_id)
            if not camera_info:
                error_msg = self.config.get('core', 'camera_manager.messages.not_found', 
                                          'Camera not found: {camera_id}')
                logger.error(error_msg.format(camera_id=camera_id))
                return False
            
            try:
                camera_instance = self._create_camera_instance(camera_info)
                if camera_instance:
                    if alias:
                        camera_info['alias'] = alias
                    self.camera_instances[alias or camera_id] = camera_instance
                    
                    success_msg = self.config.get('core', 'camera_manager.messages.opened', 
                                                'Camera opened: {alias}')
                    logger.info(success_msg.format(alias=alias or camera_id))
                    return True
                else:
                    return False
                    
            except Exception as e:
                error_msg = self.config.get('core', 'camera_manager.messages.open_error', 
                                          'Failed to open camera: {error}')
                logger.error(error_msg.format(error=str(e)))
                return False
    
    def close_camera(self, alias: str):
        """Ferme une cam√©ra par alias"""
        with self.lock:
            if alias not in self.camera_instances:
                warning_msg = self.config.get('core', 'camera_manager.messages.not_open', 
                                            'Camera not open: {alias}')
                logger.warning(warning_msg.format(alias=alias))
                return False
            
            try:
                camera_instance = self.camera_instances[alias]
                if hasattr(camera_instance, 'stop_streaming'):
                    camera_instance.stop_streaming()
                if hasattr(camera_instance, 'close'):
                    camera_instance.close()
                
                del self.camera_instances[alias]
                
                # Nettoyage thread associ√©
                if alias in self.camera_threads:
                    del self.camera_threads[alias]
                
                success_msg = self.config.get('core', 'camera_manager.messages.closed', 
                                            'Camera closed: {alias}')
                logger.info(success_msg.format(alias=alias))
                return True
                
            except Exception as e:
                error_msg = self.config.get('core', 'camera_manager.messages.close_error', 
                                          'Failed to close camera: {error}')
                logger.error(error_msg.format(error=str(e)))
                return False
    
    def is_camera_open(self, alias: str) -> bool:
        """V√©rifie si une cam√©ra est ouverte"""
        with self.lock:
            return alias in self.camera_instances
    
    def get_camera_frame(self, alias: str) -> Optional[Dict[str, np.ndarray]]:
        """R√©cup√®re une frame d'une cam√©ra"""
        with self.lock:
            if alias not in self.camera_instances:
                return None
            
            try:
                camera_instance = self.camera_instances[alias]
                return camera_instance.get_frame()
            except Exception as e:
                error_msg = self.config.get('core', 'camera_manager.messages.frame_error', 
                                          'Failed to get frame: {error}')
                logger.error(error_msg.format(error=str(e)))
                return None
    
    def get_camera_info(self, alias: str) -> Optional[Dict]:
        """R√©cup√®re les informations d'une cam√©ra"""
        with self.lock:
            for camera_info in self.cameras.values():
                if camera_info.get('alias') == alias:
                    return camera_info
            return None
    
    def list_open_cameras(self) -> List[str]:
        """Liste des cam√©ras ouvertes"""
        with self.lock:
            return list(self.camera_instances.keys())
    
    def close_all_cameras(self):
        """Ferme toutes les cam√©ras"""
        with self.lock:
            aliases = list(self.camera_instances.keys())
            for alias in aliases:
                self.close_camera(alias)
    
    def _get_camera_info(self, camera_id: str) -> Optional[Dict]:
        """R√©cup√®re les infos d'une cam√©ra par ID"""
        for serial, info in self.cameras.items():
            if serial == camera_id or info.get('alias') == camera_id:
                return info
        return None
    
    def _create_camera_instance(self, camera_info: Dict):
        """Cr√©e une instance de cam√©ra selon le type"""
        camera_type = camera_info.get('type')
        
        if camera_type == 'realsense':
            return RealSenseCamera(camera_info, self.config)
        elif camera_type == 'usb3':
            return USB3CameraDriver(camera_info, self.config)
        else:
            error_msg = self.config.get('core', 'camera_manager.messages.unknown_type', 
                                      'Unknown camera type: {type}')
            logger.error(error_msg.format(type=camera_type))
            return None

# CORRECTION: Import de MeasuresTab d√©plac√© en bas pour √©viter les imports circulaires
# Note: Si MeasuresTab est utilis√©e dans cette classe, l'importer conditionnellement
def get_measures_tab_class():
    """Import conditionnel de MeasuresTab pour √©viter les imports circulaires"""
    try:
        from ui.measures_tab import MeasuresTab
        return MeasuresTab
    except ImportError:
        logger.warning("‚ö†Ô∏è MeasuresTab non disponible")
        return None